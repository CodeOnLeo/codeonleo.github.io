---
layout: post
title: 24.12.06 수업 내용 정리
date: 2024-12-06 12:34 +0900
description: AI 시대의 프로그래머
category: [SeSAC]
tags: [ai]
pin: false
math: true
mermaid: true
---
# AI 시대의 프로그래머
## 개발자에게 열린 새로운 세상
- 안드레이 카파티의 배경
  - 구글, 스탠퍼드, 오픈AI, 테슬라 등에서 AI 관련 경력
  - 80만명에 가까운 SNS 팔로워를 가진 인플루언서
- AI와 프로그래밍의 변화
  - "최근 가장 큰 인기를 끈 새로운 프로그래밍 언어는 영어입니다" - 트윗
  - 자연어를 코드로 변환하는 AI 도구의 등장 (예: 깃허브 코파일럿)
- AI 프로그래밍 도구의 영향과 전망
  - 개발자의 코딩 속도 향상
  - AI 어시스턴트를 활용한 효율적인 프로그래밍 방법 모색

### 검색 최소화
- 문제 탐색 과정
  - 개발자들은 문제 해셜을 위해 구글이나 스택 오버플로를 자주 이용
  - 불완전한 답변이나 해결책을 찾는 데 시간이 많이 소요됨
- 검색에 소모되는 시간
  - 스택 오버플로 설문 조사에서 많은 개발자가 답변 검색에 30분에서 1시간 이상 소요
  - 대규모 개발 팀의 경우 주간 검색 시간은 333 ~ 651 시간
- AI 어시스턴트 도입
  - GitHub Copilot: 개발 속도를 55% 가속화
  - 연구 결과: AI 어시스턴트 사용으로 더 빠른 작업 완료 가능
- 작업 효율성 개선
  - 코드를 생성, 리팩터링, 문서화하는데 AI 도구가 시간 절약에 기여
  - 복잡한 작업에서는 효과가 미미하지만, 문서화 작업에서 50% 시간 절감
- 품질 유지
  - AI 사용 후에도 코드 품질 저하 없이 유지보수성과 가독성 개선 가능
- 개발자 경험 향상
  - 반복 작업을 AI가 도와주면서 효율적으로 더 나은 코드 작성 가능

#### 맥킨지 연구
- 일상적인 작업 간소화
  - 코드 자동 완성 및 문서화 지원
  - 개발자가 복잡한 문제 해결에 집중 가능
- 보다 원활한 코드 초안 작성
  - AI 도구로 초기 코드 작성 부담 감소
  - '빈 화면 문제' 극복 및 고딩 속도 향상
- 수월한 기존 코드 개선
  - AI 제안을 통한 코드 최적화
  - 반복적인 개선 과정 효율화
- 개발자의 새로운 시도 확대
  - 새로운 코딩 환경/언어 학습 지원
  - AI가 포괄적인 가이드 제공
- 여러 도구의 활용
  - 다양한 AI 도구 조합으로 효율성 증대
  - 개발시간 1.5 ~ 2.5배 단축

### 코드베이스 반영
- AI 어시스턴트의 맞춤화
  - 프로젝트 특화 요소(내부 라이브러리, API 등) 반영
  - 기술적 견고성과 프로젝트 요구사항 충족
- 코드 품질 향상
  - 조직의 코딩 표준, 품질 기준, 보안 프로토콜 준수
  - 불필요하거나 부적절한 코드 방지
- 개발자 온보딩 가속화
  - 새로운 코드베이스 적응 시간 단축
  - AI 도구를 통한 학습 곡선 개선

### 코드 무결성
- 코드 무결성의 중요성
  - 소프트웨어의 견고함과 신뢰성을 나타냄
  - 버그와 보안 취약점 예방
- 코드 무결성 강화 방법
  - 단위/통합 테스트, 코드 리뷰, 정적 코드 분석 실시
  - 엄격한 보안 평가 수행
- AI 어시스턴트의 코드 무결성 지원
  - 세밀한 단위 테스트와 에지 케이스 발견 지원
  - 풀 리퀘스트 분석 및 릴리스 노트 자동 생성

### AI 기반 문서 생성기
- 소프트웨어 개발에서 문서화의 중요성
  - 코드베이스의 가독성, 유지관리, 확장성 향상
  - 팀 변화와 프로젝트 복잡성 증가에 대응
- 문서화 작업의 어려움
  - 시간 소모적이고 행정적인 업무로 인식됨
  - 우선순위에서 밀려나는 경향
- AI 어시스턴트 프로그래밍 도구의 등장
  - 대량의 고품질 문서를 신속하게 작성 가능
  - LLM(대규모 언어 모델)의 언어 처리 능력 활용

### 현대화
#### 필요
- 마크 앤드리슨의 "소프트웨어가 세상을 먹어 치우고 있다" 선언
  - 기술 트렌드를 예측한 통찰력 있는 선언
  - 시간이 지날수록 그 중요성이 부각됨
- IT 인프라의 성숙이 글로벌 산업 변혁 촉진
  - 클라우드 플랫폼과 광대역 인터넷의 전 세계적 확산
  - 전통적인 기술 장벽 제거로 혁신 기업 등장
- 대기업이 직면한 혁신의 어려움
  - 레거시 시스템에 대한 의존성
  - 의사결정의 어려움과 변화 수용의 복잡성

#### 노력
- IBM의 AI 기반 코드 변환 도구 개발
  - Watsonx Code Assistant for Z 공개
  - 115개 코딩 언어 이해, 200억개 매개변수 보유
- 코볼 코드 변환의 어려움과 위험성
  - 수천억 줄에 달하는 코볼 코드의 복잡성
  - 부적절한 변환 시 심각한 결과 초래 가능성
- 메인프레임 개발자 인력 문제
  - 높은 연봉에도 불구하고 인재 채용의 어려움
  - 젊은 개발자들의 메인프레임 개발 기피 현상

#### 기회
- IBM의 AI 활용 인식
  - AI가 거대한 문제 해결에 필수적이라고 인지
  - 생성형 AI로 프로젝트 결과를 10배까지 향상 가능
- 기존 코드 변환 방식의 한계
  - 수십년간 사용된 코드 트랜스파일러/변환기
  - 코볼의 스파게티 코드를 자바로 단순 번역
  - 개선이나 혁신 부족으로 많은 프로젝트 실패
- 현대화 기회 모색
  - 다른 기업들도 AI를 활용한 현대화 기회 탐색 중
  - 깃허브 CEO의 코볼 관련 언급 증가

### 한계점
#### 환각
- 환각의 정의와 영향
  - 정확해보이나 실제로는 부정확한 AI 모델의 출력
  - 소프트웨어 개발에 어려움 초리 (부정확한 코드, 오해의 소지가 있는 문서 등)
- 환각 문제 해결을 위한 노력
  - 학술 연구와 AI 기업의 방법론 적용 (예: RLHF)
  - 완전한 근절은 어려우나 지속적인 개선 진행 중
- 프로그래밍 언어별 AI 성능 차이
  - 파이썬, 자바스크립트, 타입스크립트, 고 등이 더 나은 성능 보임
  - 공개 리포지터리의 풍부한 데이터셋이 주요 요인

#### 지적 재산권
- 매튜 버터릭의 깃허브 코파일럿 소송
  - 타이포그래피 전문가인 매튜 버터릭이 코파일럿에 대해 부정적 견해를 표명
  - 마이크로소프트, 깃허브, 오픈AI를 상대로 집단 소송 제기
- AI 생성 콘텐츠의 저작권 문제
  - AI 어시스턴트가 생성한 코드의 지적 재산권 문제 대두
  - '공정 이용' 개념과 관련된 법적 근거 부족으로 연방 법률이나 대법원 판결 필요
- 오픈소스와 AI 어시스턴트의 충돌
  - GPL 등 오픈소스 라이선스와 AI 생성 코드 간의 충돌 가능성
  - 개발자들의 지적 재산권 보호와 코드 공개 요구 사이의 딜레마

#### 개인정보 보호
- AI 어시스턴트 프로그래밍 도구의 데이터 프라이버시 문제
  - 클라우드 저장 시 데이터 보호 및 기밀 유지 우려
  - 학습 데이터로 사용 가능성에 대한 의문
- 그리드 스페이스의 자체 AI 어시스턴트 프로그래밍 플랫폼 개발 사례
  - 쿠버네티스 클러스터와 도커 서비스 기반 맞춤형 시스템 구축
  - IP와 데이터 보호를 위해 자체 코드베이스에 맞게 미세 조정
- AI 어시스턴트 프로그램 도입 시 고려사항
  - 조직별 선호 방식이 다를 수 있음
  - 개인정보 보호에 미치는 영향 이해의 중요성

#### 보안
- 깃허브 코파일럿 생성 코드의 보안 취약점 연구 결과
  - AI 생성 코드 452개 중 29.8%에서 공통 약점 열거(CWE) 사항 발견
  - 38개의 서로 다른 CWE 카테고리에 걸친 다양한 문제 확인
- 주요 보안 취약점 유형
  - OS 명령 주입, 불충분한 무작위 값 사용, 예외 조건의 부적절한 처리 등
  - 11개 항목이 2022년 CWE 상위 25개 리스트에 포함됨
- AI 프로그래밍 도구의 보안 관련 시사점
  - AI 도구 개발 업체들의 지속적인 안전망 개선 노력
  - AI 생성 코드도 일반 코드와 마찬가지로 철저한 보안 검토 필요

#### 학습 데이터
- 대표성 격차
  - 특정 프로그래밍 영역의 오픈소스 부족
  - AI 제안의 정확도 저하
- 품질 불일치
  - 프로젝트별 AI 도움의 품질 차이
  - 사용자 경험의 일관성 부족
- 학습된 데이터의 기간
  - 특정 시점까지의 데이터만 반영
  - 최신 업데이트나 변경사항 미반영
- 일반화 격차
  - 학습 데이터와 실제 사용 데이터 간 성능 차이
  - 새로운 상황에 대한 대응력 한계
- 컨텍스트 이해
  - 학습 데이터 기반 제안 제공
  - 비일반적 시나리오에 대한 대응 어려움

#### 편향
- AI 윤리에 대한 개발자의 이해 부족
  - 컴퓨터 과학 교육과 부트캠프에서 AI 윤리 교육 부재
  - 알고리즘의 의도치 않은 편견과 데이터 오용 가능성 증가
- AI 어시스턴트 프로그래밍 도구의 편견 문제
  - 학습 데이터의 편향성으로 인한 결과물 편향 (예: 영어 중심의 이름 목록)
  - 의도치 않은 유해하거나 부적절한 결과 초래 가능성
- AI의 현향된 응답 사례
  - 인종 카테고리에 대한 제한적이고 고정된 분류
  - 특정 종교(이슬람)에 대한 부정적 단어 사용 빈도 증가

### 개발자의 새로운 접근 방식
- AI 프로그래밍 도구의 영향
  - 소프트웨어 개발 접근 방식 변화 예상
  - 프롬프트 엔지니어링, 코딩 표준, 품질에 대한 모범 사례 중요성 증가
- AI 어시스턴트 프로그래밍 도구의 편견 문제
  - 초보 개발자: 프로그래밍 기본 원리 집중 학습
  - 경력 개발자: 팀 내 전문가 조언 및 커뮤니티 활동 참여
- 조직 차원의 대응
  - 지속적 학습 문화 조성 (예: 온라인 포럼 참여, 팀 모임)
  - 관리자 역할 변화 및 고부가가치 작업 집중

#### 커리어
- 채용 시장 동향
  - 구인 사이트에서 AI 어시스턴트 경험자 수요 증가
  - 주니어부터 시니어까지 전 직급 대상 채용 공고 증가
- 생산성 향상 효과
  - 품질 유지하며 업무 효율성 증대
  - 개발자의 조직 내 승진 기회 확대
- 개발자들의 선호도
  - AI 프로그래밍 도구에 대한 개발자 커뮤니티의 긍정적 평가
  - 깃허브 코파일럿 등 주요 도구의 높은 사용자 만족도

#### 10x 개발자
- 10x 개발자의 정의
  - 개발자 10명의 퍼포먼스를 보이는 개발자
  - 문제를 빠르게 파악하고 해결하는 '코딩의 우사인 볼트'
- AI 도구로 10x 개발자 되기의 한계
  - AI로 업무 속도 향상 가능하나 개선 폭이 제한적
  - 10x 개발자 되기는 현실적으로 어려움
- 10x 개발자 개념의 부작용
  - 고정관념과 편견 유발 가능성
  - 과도한 부담으로 인한 번아웃 위험

#### AI 어시스턴트 도입시 고려 사항
- 오류 수정
  - AI의 실수 발견 및 수정은 개발자의 책임
  - 정확한 결과를 위해 추가 정보 제공 및 수정 필요
- 조직 특성 반영
  - AI는 개별 프로젝트나 조직의 특성을 완전히 반영하지 못함
  - 조직 목표, 성과, 보안에 부합하는 결과 도출 필요
- 복잡한 문제 해결
  - AI는 단순 작업에 유용하나 복잡한 과제에 한계 존재
  - 숙련된 개발자의 역량으로 해결 필요

## AI 어시스턴트의 작동원리
### AI 어시스턴트
#### 주요 기능
|기능|설명|
|--|--|
|코드 제안|주석 및 파일의 컨텍스트를 기반으로 코드를 제안하고 개별 코드나 전체 함수를 추천합니다.|
|컨텍스트 기반 코드 자동 완성|코드베이스의 전체나 일부를 기반으로 코드 자동 완성 기능과 코드 작업에 도움이 되는 제안들을 제공합니다.|
|테스트 생성|코드를 분석해 의미 있는 테스트를 생성하고, 코드 동작을 매핑하고, 에지 케이스를 표면해 출시 전에 소프트웨어 안정성을 보장합니다.|
|사용자 IDE 상호작용|사용자가 IDE에 코드를 입력하면 자동으로 활성화되고 안내를 제공하며, 사용자는 채팅을 통해 코드와 상호작용할 수 있습니다.|
|코드 분석|코드 스니펫, 문서 문자열, 주석을 분석해 신뢰할 수 있는 코드를 예측하고 의심스러운 코드에 태그를 지정합니다.|
|버그 검지 및 수정|코드에서 잠재적인 버그를 식별하고 이를 수정하는 방법을 제안합니다.|
|코드 자동 문서화|자동으로 문서 문자열을 추가하고 코드 문서를 개선합니다.|
|일상적인 직접 자동화|일상적이거나 시간이 많이 걸리는 작업, 익숙하지 않은 API 또는 SDK, 파일 작업, 이미지 처리 같은 기타 일반적인 코딩 시나리오를 위한 코드 작성에 도움을 줍니다.|
|API 및 SDK 사용 최적화|API와 SDK를 정확하고 효과적으로 사용할 수 있도록 도와줍니다.|
|오픈소스 검색 및 출처 표기|오픈소스 코드와 라이브러리의 검색 및 출처 표기를 용이하게 합니다.|

#### 지능형 코드 완성과의 비교
- 지능형 코드 완성 기능의 발전
  - 1950년대 맞춤법 검사기에서 시작
  - 1990년대 마이크로소프트 비주얼 베이직 5.0의 실시간 제안 및 완성 기능
- 인텔리센스의 특징
  - 기본적인 문법과 메서드 시그니처에 중점
  - AI 및 머신러닝 기능 포함
- AI 어시스턴트와 인텔리센스의 차이점
  - 생성형 AI 기반으로 더 넓은 범위의 작업 수행 가능
  - 컨텍스트와 의도를 파악하여 사람과 유사한 상호작용 제공

#### 컴파일러 수행 단계
1. 어휘 분석(토큰화)
    - 소스 코드를 개별 토큰으로 분리
    - 각 토큰의 유형 식별 (예: 식별자, 키워드, 상수 등)
2. 구문 분석
    - 파싱 트리 생성
    - 문법 규칙 검증
3. 의미 분석(오류 검사)
    - 타입 검사
    - 변수 선언 및 범위 확인
4. 중간 코드 생성
    - 추상 구문 트리(AST) 생성
    - 3주소 코드 또는 쿼드러플 생성
5. 코드 최적화
    - 불필요한 코드 제거
    - 루프 최적화
6. 코드 생성
    - 목표 기계에 맞는 명령어 선택
    - 레지스터 할당
7. 링킹 및 로딩
    - 외부 라이브러리와 모듈 연결
    - 메모리에 실행 가능한 프로그램 로드

#### 컴파일러와의 비교
- AI 어시스턴트의 작동 방식
  - 기존 코드를 기반으로 확률적 패턴 예측
  - 컴파일러와 달리 프로그래밍 언어를 완전히 이해하지 못함
- AI 어시스턴트의 장점
  - 구문 오류 발견 및 수정 제안 가능
  - 코딩 관행 개선 및 대안적 접근법 제시
- AI 어시스턴트의 한계
  - 간단한 오류를 놓치거나 난해한 코드를 제안할 수 있음
  - 컴파일러의 철저함과 프로그래머의 판단력을 완전히 대체할 수 없음

### 생성형 AI 및 LLM
- AI 기술에 대한 이해의 중요성
  - AI 도구의 응답, 기능, 한계를 더 잘 평가 가능
  - 전문가 수준의 지식은 불필요
- 투명성의 중요성
  - 새로운 기술의 내부 원리 설명 필요
  - 기술 도입에 있어 신뢰성이 핵심 요소
- 프로그래밍에서의 신뢰성과 책임감
  - 가장 본질적인 요소로 인식
  - 선택적이 아닌 필수적 요소

#### 진화
- ELIZA: 초기 생성형 AI의 시작
  - MIT의 조셉 바이젠바움 교수가 1960년대 중반 개발
  - 규칙 기반 알고리즘으로 심리 치료사 대화 모방
- 2010년대: 생성형 AI의 전환점
  - 연산 능력, GPU, 대규모 데이터, 딥러닝 모델의 발전
  - VAE(2013)와 GAN(2014) 등 혁신적 기술 등장
- 변이형 오토인코더(VAE)
  - 고차원 데이터를 저차원 잠재 공간으로 압축
  - 확률 분호를 통해 새로운 데이터 생성
- 생성적 적대 신경망(GAN)
  - 생성자와 판별자 신경망의 경쟁 구조
  - 실제와 유사한 데이터 생성 능력 지속 향상
- 현대 LLM으로의 발전
  - VAE와 GAN이 트랜스포머 모델 발전의 기반 마련
  - 더욱 강력하고 유연한 생성형 AI 기술로 진화

#### 트랜스포머 모델
- RNN에서 트랜스포머로의 전환
  - RNN: 순차적 처리, 장기 의존성 문제 존재
  - 트랜스포머: 병렬 처리, 어텐션 메커니즘 활용
- 트랜스포머의 주요 특징
  - 긴 시퀀스 처리 가능
  - GPU/TPU와 호환성 우수
- 트랜스포머의 구조
  - 인코딩과 디코딩 두 단계로 구성
  - 어텐션 메커니즘을 중심으로 작동

## 프롬프트 엔지니어링
- 프롬프트 엔지니어링의 정의와 목표
  - 머신러닝과 NLP의 하위 분야로, 컴퓨터의 인간 언어 이해 및 해석 연구
  - AI 시스템(LLM)과 효과적으로 대화하여 원하는 답변 생성
- 효과적인 프롬프트 작성 방법
  - 컨텍스트 설명과 명확한 요구사항 제시
  - 필요시 힌트나 추가 정보 삽입
- 반복적인 대화 과정
  - 원하는 정보를 얻을 때까지 질문 수정 및 대화 지속
  - 구체적인 요구사항에 맞춰 AI 응답 개선 (예: 웹 애플리케이션 개발 시나리오)

### 예술과 과학
- 예술과 과학의 융합
  - 창의성과 직관이 필요한 예술적 측면
  - AI 모델에 대한 이해와 체계적 접근이 필요한 과학적 측면
- 소프트웨어 개발과의 차이점
  - 더 자유롭고 예측 불가능한 특성
  - 논리적 규칙보다 언어와 맥락에 민감
- 지속적인 학습과 적응이 필요한 분야
  - 단일 해결책이나 '비법'이 존재하지 않음
  - AI 기술의 빠른 발전으로 인한 끊임없는 변화

### 도전 과제
- 장황함
  - 불필요하게 긴 답변 생성
  - 관련 없는 정보 추가 경향
- 서비스별 차이
  - LLM 간 프롬프트 효과 차이
  - 각 모델의 고유한 특성으로 인한 조정 필요성
- 길이 민감성
  - 긴 프롬프트에 대한 집중력 저하
  - 일부 정보 간과 또는 오해 가능성
- 모호성
  - 불명확한 프롬프트로 인한 혼란
  - 부정확하거나 관련 없는 답변 제공 위험

### 프롬프트
#### 지시
- 프롬프트에는 명확한 지시 사항이 필요함
  - 최소한 하나의 명확한 지시 포함
  - 너무 많은 지시는 혼란을 야기할 수 있음
- 과도한 지시의 문제점
  - 모호성 증가로 LLM이 혼란을 겪을 수 있음
  - LLM의 처리 부담 증가로 실수 가능성 높아짐
- 효과적인 프롬프트 작성 전략
  - 단순화: 복잡한 질문을 작은 단위로 나누기
  - 순차적 접근: 대화를 주고받는 방식으로 진행하기

#### 환각 발생 이유
- 사실 검증 결여
  - 패턴 기반 응답 생성
  - 정확성 확인 능력 부족
- 과적합과 암기
  - 반복 데이터의 무비판적 학습
  - 부정확한 정보 암기 가능성
- 학습 데이터의 편향성
  - 편향된 데이터 반영
  - 부정확하거나 허위 정보 포함 가능성
- 추정 및 추측
  - 불충분한 데이터에 대한 추론
  - 패턴 기반 정보 생성
- 컨텍스트 부족 또는 오해
  - 불완전한 컨텍스트로 인한 부정확한 응답
  - 프롬프트 의도 오해 가능성
- 속어 및 관용구 
  - 모호한 표현 이해의 어려움
  - 충분한 학습 예시 부족으로 인한 오해

## ChatGPT
### 모바일 앱
- 음성 채팅 기능
  - 홈 화면 오른쪽 하단의 헤드폰 버튼으로 시작
  - 5가지 음성 중 선택 가능
- 이미지 공유 및 분석
  - 사진을 찍어 챗GPT와 대화 시작 가능
  - 사물, 랜드마크, 코드 등 다양한 이미지 분석
- 이미지 생성 및 편집 기능
  - 새로운 이미지 생성 가능
  - 기존 이미지 편집 기능 제공

### 반복적인 작업
- 소프트웨어 개발의 복잡성
  - 기획, 코딩, 테스트 등 다양한 단계로 구성
  - 지속적인 신기술 학습 필요
- 반복적이고 시간 소모적인 작업
  - 동일하거나 유사한 코드의 반복 작성
  - 버그 수정 및 코드 검토
- LLM(대규모 언어 모델)의 역할
  - 챗GPT 등을 활용한 개발 작업의 효율성 향상
  - 지루한 작업 감소 및 창의적 업무에 집중 가능

## 기획
### 요구사항 작성
- 방향 제시
  - 목표 명확화, 계획 이해 증진
- 이해 공유
  - 모든 관계자의 기대 정렬, 오해 감소
- 계획 수립 지원
  - 작업, 시간, 비용 예측 용이
- 커뮤니케이션 개선
  - 특히 대규모/분산 팀에서 의사소통 향상
- 위험 감소
  - 초기 문제 식별로 지연 방지 및 비용 관리

### 테스트 주도 개발
- Given-When-Then(GWT)
  - 사용자 중심적 접근: 비기술적 이해관계자와의 협업에 적합
  - 3단계 구조: 초기 상태 준비(Given), 코드 실행(When), 결과 검증(Then)
- Arrange-Act-Assert(AAA)
  - 기술적 실행에 중점: 개발자 중심의 테스트 구조
  - GWT와 유사한 3단계: 준비(Arrange), 실행(Act), 검증(Assert)
- Setup-Exercise-Verify-Teardown(SEVT)
  - 통합 및 시스템 테스트에 적합: 더 복잡한 테스트 시나리오 처리
  - 4단계 구조: 환경 준비(Setup), 실행(Exercise), 확인(Verify), 정리(Teardown)

## 코딩
### 리팩터링
- 리팩터링의 본질
  - 코드 정리 및 재구성
  - 기능 추가나 버그 수정 이상의 의미
- 리팩터링의 이점
  - 코드의 직관성과 이해도 향상
  - 효율성 증대 및 버그 감소
- AI 도구를 활용한 리팩터링
  - 복잡한 코드 정리 및 간결화
  - 리팩터링 과정의 효율성 향상

### 함수 작성 가이드라인
- 단일 기능 수행
  - 하나의 작업에 전문화
  - 쉬운 이해와 유지보수
- 명확한 이름 지정
  - 함수의 역할을 정확히 설명하는 이름 사용
  - 코드 가독성 향상
- 간결성 유지
  - 화면에서 한 번에 볼 수 있는 길이
  - 버그 발생 가능성 감소
- 매개변수 사용
  - 입력값에 매개변수 사용
  - 출력값에 반환값 사용
- 일관성 유지
  - 프로젝트의 코딩 규칙 준수
  - 균일하고 읽기 쉬운 코드 작성

### 프런트엔드 개발
- 핵심 기술
  - HTML, CSS, JavaScript를 이용한 웹 페이지 구조화 및 디자인
  - React, Vue 등의 프레임워크를 활용한 동적이고 매력적인 웹사이트 구축
- 기술적 도전
  - 다양한 환경(디바이스, 화면 크기, 사용자 설정 등)에 대한 대웅
  - 빠르게 변화하는 프레임워크와 기술 트렌드 따라가기
- UX/UI 디자인 역량
  - 시각적으로 매력적이고 사용자 친화적인 인터페이스 설계
  - 사용자 경험과 앱/웹사이트의 논리적 흐름에 대한 이해

#### AI 도구
- TeleportHQ
  - 시각적으로 정적 웹사이트와 웹 앱을 제작하고 배포할 수 있는 저코드 플랫폼
- Anima
  - Figma, Sketch, Adobe XD 디자인을 개발자 친화적인 코드로 변환해주는 도구
- Locofy
  - 디자인 파일을 프로덕션 준비가 된 코드로 빠르게 변환하는 플랫폼
- v0 by Vercel
  - 풀스택 웹 앱을 서버리스 방식으로 쉽게 만들 수 있는 Vercel의 도구

## 디버깅, 테스트, 배포
### 디버깅
- 디버깅의 중요성
  - 개발 시간의 35-50%를 차지
  - 프로젝트의 큰 비용 요소
- 구문 오류
  - 언어의 구조와 규칙을 따르지 않아 발생
  - 최신 IDE로 대부분 감지 및 수정 가능
- 논리적 오류
  - 코드 로직이 의도와 다르게 동작하는 문제
  - 발견과 수정이 더 어려움
- 전통적인 디버깅 방법
  - 수동 코드 검토
  - IDE의 디버깅 도구 활용 (예: VS Code)
- 복잡한 버그의 원인
  - 소프트웨어의 복잡한 구조와 예상치 못한 상호작용
  - 부족한 문서화
- 외부 의존성 관련 문제
  - 외부 라이브러리나 서비스에 의존
  - 해결이 더 어려울 수 있음

### 문서
- 문서화의 중요성
  - 프로젝트의 안정성 유지
  - 코드 이해와 정보 공유 촉진
- 문서화 부족의 문제점
  - 개발자의 68%가 코드 이해에 어려움 겪음
  - 비용 증가와 비효율적인 개발 프로세스 초래
- 양질의 문서화의 이점
  - 팀 생산성 최대 55% 향상 가능
  - 명확한 방향성 제시로 효율적인 개발 지원

#### 고려사항
- 잠재적 사용자 파악
  - 대상 독자의 기술 수준 고려
  - 사용자의 필요에 맞는 정보 제공
- 간결함 유지
  - 불필요한 전문 용어 피하기
  - 명확하고 간단한 문장 사용
- 일관된 문서화 양식
  - 일관된 스타일과 형식 유지
  - 통일된 제목 구조 사용
- 예시 활용
  - 실제 사례나 코드 예시 제공
  - 단계별 안내나 스크린샷 포함
- 설명과 관련된 사진 첨부
  - 복잡한 개념에 대한 도표 사용
  - 스크린샷이나 동영상으로 시각화
- 방법과 더불어 이유도 설명
  - 각 단계의 목적 설명
  - 전체 과정의 의미와 중요성 제시

### 코드 리뷰
#### 풀 리퀘스트
- PR(Pull Request)의 중요성
  - 팀 협업과 코드 품질 향상을 위한 도구
  - 대규모 프로젝트에서 작업 추적에 유용
- 효과적인 PR 설명 작성법
  - 변경 사항의 내용, 이유, 방법을 명확히 기술
  - 구체적인 세부 정보와 의견이 필요한 부분 언급
- ChatGPT를 활용한 PR 설명 개선
  - PR 설명 초안 작성 및 기존 설명 개선에 도움
  - PR 레이아웃 최적화 및 기술적 내용 단순화 지원

### 배포
- 사용자 경험과 피드백
  - 실제 사용자의 소프트웨어 사용 관찰
  - 개선을 위한 귀중한 피드백 수집
- 실제 환경에서의 성능과 안정성
  - 다양한 하드웨어, 네트워크, 설정에 따른 문제 발생 가능성
  - 대규모 사용자 수용을 위한 견고성 확보
- 보안과 유지보수
  - 악의적 사용자 차단 및 개인정보 보호 규칙 준수
  - 지속적 통합과 배포를 위한 자동화 프로세스 구축

#### 사용자 피드백
- 사용자 피드백의 중요성
  - 소프트웨어의 안정성과 사용자 만족도 향상
  - 문제 조기 진단 및 예방 가능
- 사용자 피드백의 다양한 가치
  - 숨겨진 버그 발견
  - 새로운 기능이나 제품 개발에 활용 가능한 아이디어 제공
- 고객 서비스 향상을 위한 솔루션
  - 다양한 고객 서비스 도구 활용 (예: 젠데스, 프레시데스크 등)
  - 생성형 AI를 활용한 대량의 비정형 데이터 처리

## AI 시대의 개발자를 위한 팁
### AI가 바꾼 프로그래밍 방식
- 급속한 기술 발전
  - 숙련된 개발자에게도 도전적인 영역
  - 새로운 기술과 산업 환경의 변화로 학습 난도 상승
- 기존 프로그래밍 방식과의 차이
  - 복잡하고 불확실한 프로그래밍 방식
  - 선형적 개발 방법과 대비되는 비직관적 접근
- 개발자에게 요구되는 새로운 역량
  - AI 출력 결과 해석 능력 필요
  - 논리적 사고를 넘어선 새로운 사고방식 적응

### AI 어시스턴트의 이점
- 개발 환경 내 문제 해결
  - 개발 환경을 벗어나지 않고 문제 해결 가능
  - 작업 집중도 향상 및 전환 비용 감소
- 맞춤형 코드 제안
  - 사용자의 코딩 스타일 학습 및 적용
  - 프로젝트 특성에 맞는 제안 제공
- 반복적이고 지루한 작업 효율화
  - 파일처리, API 호출, UI 작업 등 효율적 수행
  - 코드 이해 및 문서화(주석 작성) 지원

### AI 어시스턴트의 유의점
- 법적 및 윤리적 문제
  - 저작권 및 소유권 이슈
  - 수익 분배에 대한 불명확성
- 보안 및 품질 문제
  - 생성된 코드의 보안 취약성
  - 비효율적인 코드 생성 가능성
- 개인정보 보호 문제
  - 비공개 데이터 학습으로 인한 개인정보 유출 위험
  - 개인정보 보호 규정(예: GDPR) 준수 필요성

### 프롬프트 엔지니어링의 특성
- 프롬프트 엔지니어링의 이중적 특성
  - 예술적 측면: 창의성과 요령이 필요
  - 과학적 측면: AI 모델의 작동 원리 이해 필요
- 효과적인 프롬프트 작성 방법
  - 적절한 길이 유지: 너무 길면 AI가 혼란을 겪을 수 있음
  - 구체적인 요구사항 설명
- 프롬프트의 핵심 요소
  - 명료성: 분명하고 이해하기 쉬운 표현 사용
  - 충분한 컨텍스트 제공: 원하는 응답을 얻기 위해 필요


### 프로그래밍 이상의 작업
- AI 도구의 다양한 활용
  - 아이디어 발굴 및 프로젝트 기획
  - 필요한 자료 수집
- 문서 작성 및 제품 개발 지원
  - 제품 요구사항 정의서 작성
  - 소프트웨어 요구사항 명세서 작성
- 제품 출시 및 개선
  - 제품 홍보 마케팅 기획
  - 사용자 피드백 분석 및 애플리케이션 개선

### 클로드 아티팩트
#### 주요기능
- 콘텐츠 생성 및 표시
  - 다양한 콘텐츠 생성 (코드, 문서, 웹사이트 디자인 등)
  - 전용 창에 생성된 콘텐츠 표시
- 실시간 편집 및 통합
  - 생성된 아티팩트의 실시간 보기 및 편집
  - 프로젝트에 쉽게 통합 가능
- 협업 작업 환경
  - 대화형 AI를 넘어선 동적 작업 공간 제공