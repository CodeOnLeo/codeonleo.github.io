---
layout: post
title: 서비스 아키텍처
date: 2024-07-27 11:10 +0900
description: 모놀리식 아카텍처와 마이크로서비스 아키텍처
category: [MSA, SPRING BOOT FOR MSA]
tags: [MSA, Spring Boot]
pin: false
math: true
mermaid: true
---

# 1. 마이크로서비스 아키텍처

## 1.1 모놀리식 아키텍처 (Monolithic Architecture)
- 하나의 시스템이 서비스 전체 기능을 처리하도록 설계한 것

### 1.1.1 장점
![monolithic_architecture](/assets/img/monolithic%20architecture.jpg){: width="600"}
- 하나의 WAS에서 모든 기능을 처리하여 구조가 간단하다
  - 시스템 운영과 개발에 편리
- 데이터 저장소, 애플리케이션, 코드베이스가 하나씩만 있으면 된다
  - 데이터가 객체 사이에서 전달
  - 네트워크로 인한 지연이나 데이터 유실 걱정이 없다
  - RDB의 트랜잭션 기능 사용이 쉽다
  - 단위 테스트나 통합 테스트를 작성하기 쉽다
- 여러 클래스에서 발생하는 로그를 하나의 파일에 기록할 수 있다
  - 시스템 장애나 기능의 버그 원인 파악이 쉽다

### 1.1.2 단점
- 하나의 애플리케이션 서버에서 여러 기능을 제공
  - 서비스 기능이 많아지면 스파게티 코드가 되기 쉽다
  - 코드베이스에 클라이언트 코드와 서버 코드를 포함해야 한다
  - 클라이언트 기능을 수정할 때도 서버를 재실행 해야 할 경우가 생긴다
- 모바일까지 확장하면 REST-API 사용을 위해 코드베이스에 JSON 직렬화/역직렬화 코드를 추가해야한다
  - 중요도가 낮은 부가적인 코드 때문에 소스코드 증가, 복잡도 증가, 빌드 시간 증가, 생산성 감소
- 서비스 고도화의 한계

### 1.1.3 수평적 확장 : 스케일아웃
![scaleout](/assets/img/scaleout.jpg){: width="600"}
- 점차 늘어나는 사용자의 요청, 시스템 안정성을 위해 고가용성(High Availablity) 확보 필요
- L4, L7 등 하드웨어나 HAproxy 등의 소프트웨어 로드 밸런서 사용
  - 로드 밸런서는 모든 클라이언트의 요청을 1차로 받아서 WAS에 클라이언트 요청을 재분배(분산 부하)
  - 스케일아웃 : 로드 밸런서에 연결된 WAS 인스턴스 숫자를 늘려서 전체 처리량을 늘리는 것

## 1.2 마이크로서비스 아키텍처 (Micro Service Architecture)
![msa](/assets/img/msa.jpg){: width="600"}
- 기능 위주로 나뉜 여러 애플리케이션이 있고, 각각 독립된 데이터 저장소 사용
- 애플리케이션은 인터페이스를 통해 유기적으로 동작하고 일관된 형태의 API로 제공
- 마이크로서비스 (microservice) : 기능별로 쪼개진 작은 서비스 혹은 시스템
- 대규모 시스템, 분산처리 시스템, 컨포넌트들의 집합, 시스템 확장
- 느슨한 결합 (loosely coupled) : 각 마이크로서비스는 독립적으로 동작해야하고 다른 마이크로서비스에 의존성을 최소화해야 한다
  - 마이크로서비스마다 각각 독립된 데이터 저장소가 필요하다 (RDBMS)
- 각 마이크로서비스 컴포넌트의 기능 연동은 API를 통해 데이터 전달
  - API가 사용하는 네트워크 프로토콜이 성능 저하의 원인이 될 수 있다
  - 직렬화 / 역직렬화
  - JSON 형식의 메시지, HTTP 기반의 REST-API를 가장 많이 사용
  - gRPC, Thrift, Avro, Protobuffer
  - 비동기 (AMQP 프로토콜) : RabbitMQ, Kafka

### 1.2.1 특징
1. 잘 분리된 마이크로서비스로 인한 탈중앙화
2. 대규모 시스템을 위한 아키텍처
3. 가벼운 네트워크 프로토콜
4. 느슨한 결합
5. 서비스 지향 아키텍처

### 1.2.2 장점
- 독립성 : 하나의 마이크로서비스는 하나의 비즈니스 기능을 담당한다
  - 다른 마이크로서비스와 간섭이 최소화
- 대용량 데이터를 저장하고 처리하는 데 비교적 자유롭다
- 시스템 장애에 견고하다
- 서비스 배포 주기가 빠르다
![ci_cd](/assets/img/ci_cd.jpg){: width="600"}
  - CI (Continuous Integration)
    - 지속적인 통함, 개발자가 개발한 소스 코드가 지속적으로 코드베이스에 통합
    - 자동으로 빌드 및 테스트 진행
    - 대표적인 시스템 : Jenkins 
  - CD (Continuous Deploy)
    - 지속적인 배포, CI 후 자동으로 해당 시스템에 배포
- 서비스 전체적으로 확장성이 좋아진다
- 사용자 반응에 민첩하게 대응할 수 있다

### 1.2.3 단점
- 개발하기 어렵다
  - 분리된 테이터, 네트워크를 통한 데이터 통합 필요
  - RDBMS의 최대 장점인 DB 트랜잭션 사용 불가
  - 네트워크 지연 발생 가능
  - 데이터 직렬화 / 역직렬화 비용 발생
- 운영하기 어렵다
  - 정상적으로 처리되지 않은 요청의 에러 지점을 찾기 어렵다
  - 분산 트랜잭션이 없으면 데이터 일관성을 유지하기 어렵다
- 설계하기 어렵다
  - 마이크로서비스의 크기를 정하는 기준을 세우기가 어렵다
- 서비스 운영에 여러가지 자동화된 시스템이 필요하다
  - CI / CD 시스템, 모니터링 시스템, 로그 통합 검색 시스템 등
- 개발자의 기술력이 좋아야 한다

## 1.3 마이크로서비스 아키텍처 설계

### 1.3.1 서비스 세분화 원칙 (Service granularity principle)
- 비즈니스 기능
  - 비즈니스 기능으로 서비스를 나눈다
- 성능
  - 성능에 비해 서비스의 크기가 너무 커서 오버헤드가 발생하는 경우 해당 서비스를 나누는 것을 고려한다
- 메시지 크기
  - API를 설계하는 데 메시지 크기가 크다면 서비스를 나누는 것을 고려한다
  - 단, 비스니스 기능이나 일관성을 유지하는 트랜잭션에 문제가 없다면 무시해도 좋다
- 트랜잭션
  - 데이터 정합성을 유지하는 트랜잭션으로 서비스를 나눈다
  - 데이터 기준의 서비스 분리 방법

### 1.3.2 도메인 주도 설계(DDD)의 바운디드 컨텍스트
- 바운디드 컨텍스트 (Bounded context) : 도메인 모델이 존재하는 다른 도메인 모델과 확연히 구분되는 명시적인 경계
- 바운디드 컨텍스트로 설계하면 중복될 확률이 줄어든다

### 1.3.3 단일 책임 원칙
- 모든 클래스는 하나의 책임을 가지며, 그 클래스의 기능은 책임을 기반으로 개발되어야 한다

### 1.3.4 가벼운 통신 프로토콜
- 마이크로서비스 사이의 네트워크 통신은 가벼워야 하며, 프로토콜은 특정 기술이나 언어에 의존성이 없어야 한다

### 1.3.5 외부 공개 인터페이스
- 외부에 공개하는 인터페이스를 설계할 때는 신중해야 한다
- 즉각작인 수정이나 변경이 힘들어 버전 변경 같은 방법을 이용한다

### 1.3.6 마이크로서비스마다 독립된 데이터 저장소
- 동일한 데이터 저장소 사용은 마이크로서비스 독립성에 위배된다
- 하나의 데이터베이스를 사용하면 join query나 foreign key를 설정하는 순간 테이블의 데이터 독립성은 무효화

## 1.4 12 요소 애플리케이션 (12Factors App)
- 클라우드 컴퓨팅 환경에 적합한 애플리케이션 개발 방법

1. 코드베이스 : 버전 관리되는 하나의 코드베이스와 다양한 배포
2. 의존성 : 명시적으로 선언할 수 있고 분리할 수 있는 의존성
3. 설정 : 환경 변수를 이용한 설정
4. 지원 서비스 : 지원 서비스는 연결된 리소스로 처리
5. 빌드, 릴리스, 실행 : 소스 빌드와 실행은 완전히 분리되어야 한다
6. 프로세스 : 애플리케이션은 하나 이상의 무상태 프로세스로 실행되어야 한다
7. 포트 바인딩 : 포트 바인딩을 통한 서비스 공개
8. 동시성 : 프로세스들을 통한 수평 확장
9. 폐기 기능 : 프로세스는 빠르게 시작해야 하고 안정적으로 종료해야 한다
10. Dev 환경과 Production 환경 일치
11. 로그 : 로그는 이벤트 스트림으로 다룬다
12. admin 프로세스 : 시스템 유지 보수를 위한 일회성 프로세스